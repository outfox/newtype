using Microsoft.CodeAnalysis;
using System.Text;

namespace TypeAlias.Generator;

/// <summary>
/// Generates the implementation code for a type alias.
/// </summary>
internal class AliasCodeGenerator
{
    private readonly Compilation _compilation;
    private readonly AliasInfo _alias;
    private readonly StringBuilder _sb = new();
    private readonly string _structName;
    private readonly string _aliasedTypeName;
    private readonly string _aliasedTypeFullName;
    private readonly string _namespace;
    private readonly bool _isReadonly;

    public AliasCodeGenerator(Compilation compilation, AliasInfo alias)
    {
        _compilation = compilation;
        _alias = alias;
        _structName = alias.StructSymbol.Name;
        _aliasedTypeName = alias.AliasedType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        _aliasedTypeFullName = alias.AliasedType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var ns = alias.StructSymbol.ContainingNamespace;
        _namespace = ns is { IsGlobalNamespace: false } ? ns.ToDisplayString() : "";
        _isReadonly = alias.StructDeclaration.Modifiers.Any(Microsoft.CodeAnalysis.CSharp.SyntaxKind.ReadOnlyKeyword);
    }

    public string Generate()
    {
        _sb.Clear();
        
        AppendHeader();
        AppendNamespaceOpen();
        AppendStructOpen();
        
        AppendField();
        AppendConstructors();
        AppendValueProperty();
        AppendImplicitOperators();
        AppendBinaryOperators();
        AppendUnaryOperators();
        AppendComparisonOperators();
        AppendEqualityMembers();
        AppendStaticMembers();
        AppendInstanceMembers();
        AppendToString();
        AppendGetHashCode();
        
        AppendStructClose();
        AppendNamespaceClose();

        return _sb.ToString();
    }

    private void AppendHeader()
    {
        _sb.AppendLine("// <auto-generated/>");
        _sb.AppendLine("#nullable enable");
        _sb.AppendLine();
        _sb.AppendLine("using System;");
        _sb.AppendLine("using System.Runtime.CompilerServices;");
        _sb.AppendLine();
    }

    private void AppendNamespaceOpen()
    {
        if (!string.IsNullOrEmpty(_namespace))
        {
            _sb.AppendLine($"namespace {_namespace}");
            _sb.AppendLine("{");
        }
    }

    private void AppendNamespaceClose()
    {
        if (!string.IsNullOrEmpty(_namespace))
        {
            _sb.AppendLine("}");
        }
    }

    private void AppendStructOpen()
    {
        var indent = string.IsNullOrEmpty(_namespace) ? "" : "    ";
        var readonlyMod = _isReadonly ? "readonly " : "";
        var accessMod = _alias.StructSymbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public ",
            Accessibility.Internal => "internal ",
            Accessibility.Protected => "protected ",
            Accessibility.ProtectedOrInternal => "protected internal ",
            Accessibility.ProtectedAndInternal => "private protected ",
            Accessibility.Private => "private ",
            _ => ""
        };

        // Build interface list
        var interfaces = new List<string>
        {
            $"global::System.IEquatable<{_structName}>"
        };

        // Check if aliased type implements IComparable
        if (ImplementsInterface(_alias.AliasedType, "System.IComparable`1"))
        {
            interfaces.Add($"global::System.IComparable<{_structName}>");
        }

        // Check for IFormattable
        if (ImplementsInterface(_alias.AliasedType, "System.IFormattable"))
        {
            interfaces.Add("global::System.IFormattable");
        }

        var interfaceList = string.Join(", ", interfaces);
        
        _sb.AppendLine($"{indent}{accessMod}{readonlyMod}partial struct {_structName} : {interfaceList}");
        _sb.AppendLine($"{indent}{{");
    }

    private void AppendStructClose()
    {
        var indent = string.IsNullOrEmpty(_namespace) ? "" : "    ";
        _sb.AppendLine($"{indent}}}");
    }

    private void AppendField()
    {
        var indent = GetMemberIndent();
        _sb.AppendLine($"{indent}private readonly {_aliasedTypeFullName} _value;");
        _sb.AppendLine();
    }

    private void AppendConstructors()
    {
        var indent = GetMemberIndent();
        
        // Constructor from aliased type
        _sb.AppendLine($"{indent}/// <summary>Creates a new {_structName} from a {_aliasedTypeName}.</summary>");
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public {_structName}({_aliasedTypeFullName} value) => _value = value;");
        _sb.AppendLine();
    }

    private void AppendValueProperty()
    {
        var indent = GetMemberIndent();
        _sb.AppendLine($"{indent}/// <summary>Gets the underlying value.</summary>");
        _sb.AppendLine($"{indent}public {_aliasedTypeFullName} Value");
        _sb.AppendLine($"{indent}{{");
        _sb.AppendLine($"{indent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}    get => _value;");
        _sb.AppendLine($"{indent}}}");
        _sb.AppendLine();
    }

    private void AppendImplicitOperators()
    {
        var indent = GetMemberIndent();
        
        // Implicit from aliased type to alias
        _sb.AppendLine($"{indent}/// <summary>Implicitly converts from {_aliasedTypeName} to {_structName}.</summary>");
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public static implicit operator {_structName}({_aliasedTypeFullName} value) => new {_structName}(value);");
        _sb.AppendLine();
        
        // Implicit from alias to aliased type
        _sb.AppendLine($"{indent}/// <summary>Implicitly converts from {_structName} to {_aliasedTypeName}.</summary>");
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public static implicit operator {_aliasedTypeFullName}({_structName} value) => value._value;");
        _sb.AppendLine();
    }

    private void AppendBinaryOperators()
    {
        var indent = GetMemberIndent();
        var operators = GetBinaryOperators(_alias.AliasedType);

        foreach (var op in operators)
        {
            var opSymbol = GetOperatorSymbol(op.Name);
            if (opSymbol == null) continue;

            // Skip equality/inequality - handled by AppendEqualityMembers
            if (op.Name == "op_Equality" || op.Name == "op_Inequality") continue;

            // Get parameter types
            var leftType = op.Parameters[0].Type;
            var rightType = op.Parameters[1].Type;
            var returnType = op.ReturnType;

            // Generate operator with both sides as our type (if both params are the aliased type)
            if (SymbolEqualityComparer.Default.Equals(leftType, _alias.AliasedType) &&
                SymbolEqualityComparer.Default.Equals(rightType, _alias.AliasedType))
            {
                var returnTypeStr = SymbolEqualityComparer.Default.Equals(returnType, _alias.AliasedType)
                    ? _structName
                    : returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({_structName} left, {_structName} right) => left._value {opSymbol} right._value;");
                _sb.AppendLine();

                // Also generate alias op T for cross-type interop
                // e.g. Position + Velocity works via Position.+(Position, Vector3) with Velocityâ†’Vector3
                _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({_structName} left, {_aliasedTypeFullName} right) => left._value {opSymbol} right;");
                _sb.AppendLine();
            }
            // Operator with aliased type on right
            else if (SymbolEqualityComparer.Default.Equals(leftType, _alias.AliasedType) &&
                     !SymbolEqualityComparer.Default.Equals(rightType, _alias.AliasedType))
            {
                var rightTypeStr = rightType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var returnTypeStr = SymbolEqualityComparer.Default.Equals(returnType, _alias.AliasedType)
                    ? _structName
                    : returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({_structName} left, {rightTypeStr} right) => left._value {opSymbol} right;");
                _sb.AppendLine();
            }
            // Operator with aliased type on left
            else if (!SymbolEqualityComparer.Default.Equals(leftType, _alias.AliasedType) &&
                     SymbolEqualityComparer.Default.Equals(rightType, _alias.AliasedType))
            {
                var leftTypeStr = leftType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var returnTypeStr = SymbolEqualityComparer.Default.Equals(returnType, _alias.AliasedType)
                    ? _structName
                    : returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({leftTypeStr} left, {_structName} right) => left {opSymbol} right._value;");
                _sb.AppendLine();
            }
        }
    }

    private void AppendUnaryOperators()
    {
        var indent = GetMemberIndent();
        var operators = GetUnaryOperators(_alias.AliasedType);

        foreach (var op in operators)
        {
            var opSymbol = GetOperatorSymbol(op.Name);
            if (opSymbol == null) continue;

            var returnType = op.ReturnType;
            var returnTypeStr = SymbolEqualityComparer.Default.Equals(returnType, _alias.AliasedType)
                ? _structName
                : returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({_structName} value) => {opSymbol}value._value;");
            _sb.AppendLine();
        }
    }

    private void AppendComparisonOperators()
    {
        var indent = GetMemberIndent();
        
        // Check if the type already has comparison operators
        var hasLessThan = GetBinaryOperators(_alias.AliasedType).Any(o => o.Name == "op_LessThan");
        
        if (!hasLessThan && ImplementsInterface(_alias.AliasedType, "System.IComparable`1"))
        {
            // Generate comparison operators using IComparable
            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public static bool operator <({_structName} left, {_structName} right) => left._value.CompareTo(right._value) < 0;");
            _sb.AppendLine();
            
            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public static bool operator >({_structName} left, {_structName} right) => left._value.CompareTo(right._value) > 0;");
            _sb.AppendLine();
            
            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public static bool operator <=({_structName} left, {_structName} right) => left._value.CompareTo(right._value) <= 0;");
            _sb.AppendLine();
            
            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public static bool operator >=({_structName} left, {_structName} right) => left._value.CompareTo(right._value) >= 0;");
            _sb.AppendLine();
        }
    }

    private void AppendEqualityMembers()
    {
        var indent = GetMemberIndent();
        
        // IEquatable<T>.Equals
        _sb.AppendLine($"{indent}/// <inheritdoc/>");
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public bool Equals({_structName} other) => _value.Equals(other._value);");
        _sb.AppendLine();
        
        // Object.Equals override
        _sb.AppendLine($"{indent}/// <inheritdoc/>");
        _sb.AppendLine($"{indent}public override bool Equals(object? obj) => obj is {_structName} other && Equals(other);");
        _sb.AppendLine();
        
        // == operator
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public static bool operator ==({_structName} left, {_structName} right) => left.Equals(right);");
        _sb.AppendLine();
        
        // != operator
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public static bool operator !=({_structName} left, {_structName} right) => !left.Equals(right);");
        _sb.AppendLine();
        
        // IComparable<T>.CompareTo if applicable
        if (ImplementsInterface(_alias.AliasedType, "System.IComparable`1"))
        {
            _sb.AppendLine($"{indent}/// <inheritdoc/>");
            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public int CompareTo({_structName} other) => _value.CompareTo(other._value);");
            _sb.AppendLine();
        }
    }

    private void AppendStaticMembers()
    {
        var indent = GetMemberIndent();
        var aliasedType = _alias.AliasedType;
        
        // Get all public static properties and fields
        var staticMembers = aliasedType.GetMembers()
            .Where(m => m.IsStatic && m.DeclaredAccessibility == Accessibility.Public)
            .Where(m => m is IPropertySymbol or IFieldSymbol)
            .Where(m => !m.Name.StartsWith("op_")) // Skip operators
            .ToList();

        if (staticMembers.Count == 0) return;

        _sb.AppendLine($"{indent}#region Static Members");
        _sb.AppendLine();

        foreach (var member in staticMembers)
        {
            if (member is IPropertySymbol prop)
            {
                // Check if the property returns the aliased type
                var returnTypeStr = SymbolEqualityComparer.Default.Equals(prop.Type, _alias.AliasedType)
                    ? _structName
                    : prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                
                var needsConversion = SymbolEqualityComparer.Default.Equals(prop.Type, _alias.AliasedType);
                var valueExpr = needsConversion
                    ? $"new {_structName}({_aliasedTypeFullName}.{prop.Name})"
                    : $"{_aliasedTypeFullName}.{prop.Name}";

                _sb.AppendLine($"{indent}/// <summary>Forwards {_aliasedTypeName}.{prop.Name}.</summary>");
                _sb.AppendLine($"{indent}public static {returnTypeStr} {prop.Name}");
                _sb.AppendLine($"{indent}{{");
                _sb.AppendLine($"{indent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}    get => {valueExpr};");
                _sb.AppendLine($"{indent}}}");
                _sb.AppendLine();
            }
            else if (member is IFieldSymbol field && field.IsReadOnly)
            {
                var returnTypeStr = SymbolEqualityComparer.Default.Equals(field.Type, _alias.AliasedType)
                    ? _structName
                    : field.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                
                var needsConversion = SymbolEqualityComparer.Default.Equals(field.Type, _alias.AliasedType);
                var valueExpr = needsConversion
                    ? $"new {_structName}({_aliasedTypeFullName}.{field.Name})"
                    : $"{_aliasedTypeFullName}.{field.Name}";

                _sb.AppendLine($"{indent}/// <summary>Forwards {_aliasedTypeName}.{field.Name}.</summary>");
                _sb.AppendLine($"{indent}public static {returnTypeStr} {field.Name} => {valueExpr};");
                _sb.AppendLine();
            }
        }

        _sb.AppendLine($"{indent}#endregion");
        _sb.AppendLine();
    }

    private void AppendInstanceMembers()
    {
        var indent = GetMemberIndent();
        var aliasedType = _alias.AliasedType;

        // Get instance fields (e.g. Vector3.X, Y, Z are fields, not properties)
        var instanceFields = aliasedType.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(f => !f.IsStatic && !f.IsImplicitlyDeclared && f.DeclaredAccessibility == Accessibility.Public)
            .ToList();

        // Get instance properties
        var instanceProps = aliasedType.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && p.DeclaredAccessibility == Accessibility.Public)
            .Where(p => !p.IsIndexer) // Skip indexers
            .ToList();

        // Get instance methods (excluding special ones)
        var instanceMethods = aliasedType.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => !m.IsStatic && m.DeclaredAccessibility == Accessibility.Public)
            .Where(m => m.MethodKind == MethodKind.Ordinary)
            .Where(m => !m.Name.StartsWith("get_") && !m.Name.StartsWith("set_"))
            .Where(m => m.Name != "GetHashCode" && m.Name != "Equals" && m.Name != "ToString" && m.Name != "CompareTo")
            .ToList();

        if (instanceFields.Count == 0 && instanceProps.Count == 0 && instanceMethods.Count == 0) return;

        _sb.AppendLine($"{indent}#region Instance Members");
        _sb.AppendLine();

        // Generate field forwarders (exposed as readonly properties)
        foreach (var field in instanceFields)
        {
            var returnTypeStr = SymbolEqualityComparer.Default.Equals(field.Type, _alias.AliasedType)
                ? _structName
                : field.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var needsConversion = SymbolEqualityComparer.Default.Equals(field.Type, _alias.AliasedType);
            var valueExpr = needsConversion ? $"new {_structName}(_value.{field.Name})" : $"_value.{field.Name}";

            _sb.AppendLine($"{indent}/// <summary>Forwards {_aliasedTypeName}.{field.Name}.</summary>");
            _sb.AppendLine($"{indent}public {returnTypeStr} {field.Name}");
            _sb.AppendLine($"{indent}{{");
            _sb.AppendLine($"{indent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}    get => {valueExpr};");
            _sb.AppendLine($"{indent}}}");
            _sb.AppendLine();
        }

        // Generate property forwarders
        foreach (var prop in instanceProps)
        {
            var returnTypeStr = SymbolEqualityComparer.Default.Equals(prop.Type, _alias.AliasedType)
                ? _structName
                : prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            _sb.AppendLine($"{indent}/// <summary>Forwards {_aliasedTypeName}.{prop.Name}.</summary>");
            _sb.AppendLine($"{indent}public {returnTypeStr} {prop.Name}");
            _sb.AppendLine($"{indent}{{");
            
            if (prop.GetMethod != null)
            {
                var needsConversion = SymbolEqualityComparer.Default.Equals(prop.Type, _alias.AliasedType);
                var valueExpr = needsConversion ? $"new {_structName}(_value.{prop.Name})" : $"_value.{prop.Name}";
                _sb.AppendLine($"{indent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}    get => {valueExpr};");
            }
            
            _sb.AppendLine($"{indent}}}");
            _sb.AppendLine();
        }

        // Generate method forwarders
        foreach (var method in instanceMethods)
        {
            var returnTypeStr = method.ReturnsVoid
                ? "void"
                : SymbolEqualityComparer.Default.Equals(method.ReturnType, _alias.AliasedType)
                    ? _structName
                    : method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var parameters = string.Join(", ", method.Parameters.Select(p =>
            {
                var paramType = SymbolEqualityComparer.Default.Equals(p.Type, _alias.AliasedType)
                    ? _structName
                    : p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var refKind = p.RefKind switch
                {
                    RefKind.Ref => "ref ",
                    RefKind.Out => "out ",
                    RefKind.In => "in ",
                    _ => ""
                };
                return $"{refKind}{paramType} {p.Name}";
            }));

            var arguments = string.Join(", ", method.Parameters.Select(p =>
            {
                var refKind = p.RefKind switch
                {
                    RefKind.Ref => "ref ",
                    RefKind.Out => "out ",
                    RefKind.In => "in ",
                    _ => ""
                };
                var needsConversion = SymbolEqualityComparer.Default.Equals(p.Type, _alias.AliasedType);
                var arg = needsConversion ? $"{p.Name}._value" : p.Name;
                return $"{refKind}{arg}";
            }));

            var needsReturnConversion = !method.ReturnsVoid && 
                SymbolEqualityComparer.Default.Equals(method.ReturnType, _alias.AliasedType);
            var returnExpr = method.ReturnsVoid
                ? $"_value.{method.Name}({arguments})"
                : needsReturnConversion
                    ? $"new {_structName}(_value.{method.Name}({arguments}))"
                    : $"_value.{method.Name}({arguments})";

            _sb.AppendLine($"{indent}/// <summary>Forwards {_aliasedTypeName}.{method.Name}.</summary>");
            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            
            if (method.ReturnsVoid)
            {
                _sb.AppendLine($"{indent}public void {method.Name}({parameters}) => {returnExpr};");
            }
            else
            {
                _sb.AppendLine($"{indent}public {returnTypeStr} {method.Name}({parameters}) => {returnExpr};");
            }
            _sb.AppendLine();
        }

        _sb.AppendLine($"{indent}#endregion");
        _sb.AppendLine();
    }

    private void AppendToString()
    {
        var indent = GetMemberIndent();
        
        _sb.AppendLine($"{indent}/// <inheritdoc/>");
        _sb.AppendLine($"{indent}public override string ToString() => _value.ToString();");
        _sb.AppendLine();

        // Add IFormattable.ToString if the aliased type implements it
        if (ImplementsInterface(_alias.AliasedType, "System.IFormattable"))
        {
            _sb.AppendLine($"{indent}/// <inheritdoc/>");
            _sb.AppendLine($"{indent}public string ToString(string? format, IFormatProvider? formatProvider) => _value.ToString(format, formatProvider);");
            _sb.AppendLine();
        }
    }

    private void AppendGetHashCode()
    {
        var indent = GetMemberIndent();
        _sb.AppendLine($"{indent}/// <inheritdoc/>");
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public override int GetHashCode() => _value.GetHashCode();");
        _sb.AppendLine();
    }

    private string GetMemberIndent() => string.IsNullOrEmpty(_namespace) ? "    " : "        ";

    private IEnumerable<IMethodSymbol> GetBinaryOperators(ITypeSymbol type)
    {
        return type.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.MethodKind == MethodKind.UserDefinedOperator)
            .Where(m => m.Parameters.Length == 2);
    }

    private IEnumerable<IMethodSymbol> GetUnaryOperators(ITypeSymbol type)
    {
        return type.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.MethodKind == MethodKind.UserDefinedOperator)
            .Where(m => m.Parameters.Length == 1);
    }

    private static string? GetOperatorSymbol(string operatorName)
    {
        return operatorName switch
        {
            "op_Addition" => "+",
            "op_Subtraction" => "-",
            "op_Multiply" => "*",
            "op_Division" => "/",
            "op_Modulus" => "%",
            "op_BitwiseAnd" => "&",
            "op_BitwiseOr" => "|",
            "op_ExclusiveOr" => "^",
            "op_LeftShift" => "<<",
            "op_RightShift" => ">>",
            "op_UnaryNegation" => "-",
            "op_UnaryPlus" => "+",
            "op_LogicalNot" => "!",
            "op_OnesComplement" => "~",
            "op_Increment" => "++",
            "op_Decrement" => "--",
            "op_LessThan" => "<",
            "op_GreaterThan" => ">",
            "op_LessThanOrEqual" => "<=",
            "op_GreaterThanOrEqual" => ">=",
            "op_Equality" => "==",
            "op_Inequality" => "!=",
            _ => null
        };
    }

    private bool ImplementsInterface(ITypeSymbol type, string interfaceFullName)
    {
        // Handle generic interfaces like IComparable`1
        if (interfaceFullName.Contains("`"))
        {
            var baseName = interfaceFullName.Split('`')[0];
            return type.AllInterfaces.Any(i =>
                i.OriginalDefinition.ToDisplayString().StartsWith(baseName));
        }

        return type.AllInterfaces.Any(i => i.ToDisplayString() == interfaceFullName);
    }
}
