using Microsoft.CodeAnalysis;
using System.Text;

namespace newtype.generator;

/// <summary>
/// Generates the implementation code for a type alias.
/// </summary>
internal class AliasCodeGenerator
{
    // ReSharper disable once NotAccessedField.Local
    private readonly Compilation _compilation;
    private readonly AliasInfo _alias;
    private readonly StringBuilder _sb = new();
    private readonly string _structName;
    private readonly string _aliasedTypeName;
    private readonly string _aliasedTypeFullName;
    private readonly string _namespace;
    private readonly bool _isReadonly;

    public AliasCodeGenerator(Compilation compilation, AliasInfo alias)
    {
        _compilation = compilation;
        _alias = alias;
        _structName = alias.StructSymbol.Name;
        _aliasedTypeName = alias.AliasedType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        _aliasedTypeFullName = alias.AliasedType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var ns = alias.StructSymbol.ContainingNamespace;
        _namespace = ns is { IsGlobalNamespace: false } ? ns.ToDisplayString() : "";
        _isReadonly = alias.StructDeclaration.Modifiers.Any(Microsoft.CodeAnalysis.CSharp.SyntaxKind.ReadOnlyKeyword);
    }

    public string Generate()
    {
        _sb.Clear();
        
        AppendHeader();
        AppendNamespaceOpen();
        AppendStructOpen();
        
        AppendField();
        AppendConstructors();
        AppendValueProperty();
        AppendImplicitOperators();
        AppendBinaryOperators();
        AppendUnaryOperators();
        AppendComparisonOperators();
        AppendEqualityMembers();
        AppendStaticMembers();
        AppendInstanceMembers();
        AppendToString();
        AppendGetHashCode();
        
        AppendStructClose();
        AppendNamespaceClose();

        return _sb.ToString();
    }

    private void AppendHeader()
    {
        _sb.AppendLine("// <auto-generated/>");
        _sb.AppendLine("#nullable enable");
        _sb.AppendLine();
        _sb.AppendLine("using System;");
        _sb.AppendLine("using System.Runtime.CompilerServices;");
        _sb.AppendLine();
    }

    private void AppendNamespaceOpen()
    {
        if (!string.IsNullOrEmpty(_namespace))
        {
            _sb.AppendLine($"namespace {_namespace}");
            _sb.AppendLine("{");
        }
    }

    private void AppendNamespaceClose()
    {
        if (!string.IsNullOrEmpty(_namespace))
        {
            _sb.AppendLine("}");
        }
    }

    private void AppendStructOpen()
    {
        var indent = string.IsNullOrEmpty(_namespace) ? "" : "    ";
        var readonlyMod = _isReadonly ? "readonly " : "";
        var accessMod = _alias.StructSymbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public ",
            Accessibility.Internal => "internal ",
            Accessibility.Protected => "protected ",
            Accessibility.ProtectedOrInternal => "protected internal ",
            Accessibility.ProtectedAndInternal => "private protected ",
            Accessibility.Private => "private ",
            _ => ""
        };

        // Build interface list
        var interfaces = new List<string>
        {
            $"global::System.IEquatable<{_structName}>"
        };

        // Check if aliased type implements IComparable
        if (ImplementsInterface(_alias.AliasedType, "System.IComparable`1"))
        {
            interfaces.Add($"global::System.IComparable<{_structName}>");
        }

        // Check for IFormattable
        if (ImplementsInterface(_alias.AliasedType, "System.IFormattable"))
        {
            interfaces.Add("global::System.IFormattable");
        }

        var interfaceList = string.Join(", ", interfaces);
        
        _sb.AppendLine($"{indent}{accessMod}{readonlyMod}partial struct {_structName} : {interfaceList}");
        _sb.AppendLine($"{indent}{{");
    }

    private void AppendStructClose()
    {
        var indent = string.IsNullOrEmpty(_namespace) ? "" : "    ";
        _sb.AppendLine($"{indent}}}");
    }

    private void AppendField()
    {
        var indent = GetMemberIndent();
        _sb.AppendLine($"{indent}private readonly {_aliasedTypeFullName} _value;");
        _sb.AppendLine();
    }

    private void AppendConstructors()
    {
        var indent = GetMemberIndent();
        
        // Constructor from aliased type
        _sb.AppendLine($"{indent}/// <summary>Creates a new {_structName} from a {_aliasedTypeName}.</summary>");
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public {_structName}({_aliasedTypeFullName} value) => _value = value;");
        _sb.AppendLine();
    }

    private void AppendValueProperty()
    {
        var indent = GetMemberIndent();
        _sb.AppendLine($"{indent}/// <summary>Gets the underlying value.</summary>");
        _sb.AppendLine($"{indent}public {_aliasedTypeFullName} Value");
        _sb.AppendLine($"{indent}{{");
        _sb.AppendLine($"{indent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}    get => _value;");
        _sb.AppendLine($"{indent}}}");
        _sb.AppendLine();
    }

    private void AppendImplicitOperators()
    {
        var indent = GetMemberIndent();
        
        // Implicit from aliased type to alias
        _sb.AppendLine($"{indent}/// <summary>Implicitly converts from {_aliasedTypeName} to {_structName}.</summary>");
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public static implicit operator {_structName}({_aliasedTypeFullName} value) => new {_structName}(value);");
        _sb.AppendLine();
        
        // Implicit from alias to aliased type
        _sb.AppendLine($"{indent}/// <summary>Implicitly converts from {_structName} to {_aliasedTypeName}.</summary>");
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public static implicit operator {_aliasedTypeFullName}({_structName} value) => value._value;");
        _sb.AppendLine();
    }

    private void AppendBinaryOperators()
    {
        var indent = GetMemberIndent();
        var operators = GetBinaryOperators(_alias.AliasedType);
        var emittedOps = new HashSet<string>();

        foreach (var op in operators)
        {
            var opSymbol = GetOperatorSymbol(op.Name);
            if (opSymbol == null) continue;

            // Skip equality/inequality - handled by AppendEqualityMembers
            if (op.Name == "op_Equality" || op.Name == "op_Inequality") continue;

            emittedOps.Add(op.Name);

            // Get parameter types
            var leftType = op.Parameters[0].Type;
            var rightType = op.Parameters[1].Type;
            var returnType = op.ReturnType;

            // Generate operator with both sides as our type (if both params are the aliased type)
            if (SymbolEqualityComparer.Default.Equals(leftType, _alias.AliasedType) &&
                SymbolEqualityComparer.Default.Equals(rightType, _alias.AliasedType))
            {
                var returnTypeStr = SymbolEqualityComparer.Default.Equals(returnType, _alias.AliasedType)
                    ? _structName
                    : returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({_structName} left, {_structName} right) => left._value {opSymbol} right._value;");
                _sb.AppendLine();

                // Also generate alias op T for cross-type interop
                // e.g. Position + Velocity works via Position.+(Position, Vector3) with Velocityâ†’Vector3
                _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({_structName} left, {_aliasedTypeFullName} right) => left._value {opSymbol} right;");
                _sb.AppendLine();
            }
            // Operator with aliased type on right
            else if (SymbolEqualityComparer.Default.Equals(leftType, _alias.AliasedType) &&
                     !SymbolEqualityComparer.Default.Equals(rightType, _alias.AliasedType))
            {
                var rightTypeStr = rightType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var returnTypeStr = SymbolEqualityComparer.Default.Equals(returnType, _alias.AliasedType)
                    ? _structName
                    : returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({_structName} left, {rightTypeStr} right) => left._value {opSymbol} right;");
                _sb.AppendLine();
            }
            // Operator with aliased type on left
            else if (!SymbolEqualityComparer.Default.Equals(leftType, _alias.AliasedType) &&
                     SymbolEqualityComparer.Default.Equals(rightType, _alias.AliasedType))
            {
                var leftTypeStr = leftType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var returnTypeStr = SymbolEqualityComparer.Default.Equals(returnType, _alias.AliasedType)
                    ? _structName
                    : returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({leftTypeStr} left, {_structName} right) => left {opSymbol} right._value;");
                _sb.AppendLine();
            }
        }

        // Emit built-in operators for primitive types not discovered via UserDefinedOperator
        var builtInOps = GetBuiltInBinaryOperatorNames(_alias.AliasedType.SpecialType);
        foreach (var opName in builtInOps)
        {
            if (emittedOps.Contains(opName)) continue;
            if (opName == "op_Equality" || opName == "op_Inequality") continue;

            var opSymbol = GetOperatorSymbol(opName);
            if (opSymbol == null) continue;

            if (IsShiftOperator(opName))
            {
                // Shift operators: left is the type, right is always int
                _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}public static {_structName} operator {opSymbol}({_structName} left, int right) => left._value {opSymbol} right;");
                _sb.AppendLine();
            }
            else
            {
                // Alias op Alias
                _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}public static {_structName} operator {opSymbol}({_structName} left, {_structName} right) => left._value {opSymbol} right._value;");
                _sb.AppendLine();

                // Alias op T
                _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}public static {_structName} operator {opSymbol}({_structName} left, {_aliasedTypeFullName} right) => left._value {opSymbol} right;");
                _sb.AppendLine();

                // T op Alias
                _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}public static {_structName} operator {opSymbol}({_aliasedTypeFullName} left, {_structName} right) => left {opSymbol} right._value;");
                _sb.AppendLine();
            }
        }
    }

    private void AppendUnaryOperators()
    {
        var indent = GetMemberIndent();
        var operators = GetUnaryOperators(_alias.AliasedType);
        var emittedOps = new HashSet<string>();

        foreach (var op in operators)
        {
            var opSymbol = GetOperatorSymbol(op.Name);
            if (opSymbol == null) continue;

            emittedOps.Add(op.Name);

            var returnType = op.ReturnType;
            var returnTypeStr = SymbolEqualityComparer.Default.Equals(returnType, _alias.AliasedType)
                ? _structName
                : returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({_structName} value) => {opSymbol}value._value;");
            _sb.AppendLine();
        }

        // Emit built-in unary operators for primitive types
        var builtInOps = GetBuiltInUnaryOperatorNames(_alias.AliasedType.SpecialType);
        foreach (var opName in builtInOps)
        {
            if (emittedOps.Contains(opName)) continue;

            var opSymbol = GetOperatorSymbol(opName);
            if (opSymbol == null) continue;

            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public static {_structName} operator {opSymbol}({_structName} value) => {opSymbol}value._value;");
            _sb.AppendLine();
        }
    }

    private void AppendComparisonOperators()
    {
        var indent = GetMemberIndent();

        // Check if the type already has comparison operators
        var hasLessThan = GetBinaryOperators(_alias.AliasedType).Any(o => o.Name == "op_LessThan");

        if (!hasLessThan && ImplementsInterface(_alias.AliasedType, "System.IComparable`1"))
        {
            var isRefType = !_alias.AliasedType.IsValueType;

            string CompareExpr(string op) => isRefType
                ? $"(left._value is null ? (right._value is null ? 0 : -1) : left._value.CompareTo(right._value)) {op} 0"
                : $"left._value.CompareTo(right._value) {op} 0";

            // Generate comparison operators using IComparable
            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public static bool operator <({_structName} left, {_structName} right) => {CompareExpr("<")};");
            _sb.AppendLine();

            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public static bool operator >({_structName} left, {_structName} right) => {CompareExpr(">")};");
            _sb.AppendLine();

            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public static bool operator <=({_structName} left, {_structName} right) => {CompareExpr("<=")};");
            _sb.AppendLine();

            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public static bool operator >=({_structName} left, {_structName} right) => {CompareExpr(">=")};");
            _sb.AppendLine();
        }
    }

    private void AppendEqualityMembers()
    {
        var indent = GetMemberIndent();
        var isRefType = !_alias.AliasedType.IsValueType;

        // IEquatable<T>.Equals
        var equalsExpr = isRefType
            ? "object.Equals(_value, other._value)"
            : "_value.Equals(other._value)";
        _sb.AppendLine($"{indent}/// <inheritdoc/>");
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public bool Equals({_structName} other) => {equalsExpr};");
        _sb.AppendLine();

        // Object.Equals override
        _sb.AppendLine($"{indent}/// <inheritdoc/>");
        _sb.AppendLine($"{indent}public override bool Equals(object? obj) => obj is {_structName} other && Equals(other);");
        _sb.AppendLine();

        // == operator
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public static bool operator ==({_structName} left, {_structName} right) => left.Equals(right);");
        _sb.AppendLine();

        // != operator
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public static bool operator !=({_structName} left, {_structName} right) => !left.Equals(right);");
        _sb.AppendLine();

        // IComparable<T>.CompareTo if applicable
        if (ImplementsInterface(_alias.AliasedType, "System.IComparable`1"))
        {
            var compareExpr = isRefType
                ? "_value is null ? (other._value is null ? 0 : -1) : _value.CompareTo(other._value)"
                : "_value.CompareTo(other._value)";
            _sb.AppendLine($"{indent}/// <inheritdoc/>");
            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}public int CompareTo({_structName} other) => {compareExpr};");
            _sb.AppendLine();
        }
    }

    private void AppendStaticMembers()
    {
        var indent = GetMemberIndent();
        var aliasedType = _alias.AliasedType;
        
        // Get all public static properties and fields
        var staticMembers = aliasedType.GetMembers()
            .Where(m => m.IsStatic && m.DeclaredAccessibility == Accessibility.Public)
            .Where(m => m is IPropertySymbol or IFieldSymbol)
            .Where(m => !m.Name.StartsWith("op_")) // Skip operators
            .ToList();

        if (staticMembers.Count == 0) return;

        _sb.AppendLine($"{indent}#region Static Members");
        _sb.AppendLine();

        foreach (var member in staticMembers)
        {
            if (member is IPropertySymbol prop)
            {
                // Check if the property returns the aliased type
                var returnTypeStr = SymbolEqualityComparer.Default.Equals(prop.Type, _alias.AliasedType)
                    ? _structName
                    : prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                
                var needsConversion = SymbolEqualityComparer.Default.Equals(prop.Type, _alias.AliasedType);
                var valueExpr = needsConversion
                    ? $"new {_structName}({_aliasedTypeFullName}.{prop.Name})"
                    : $"{_aliasedTypeFullName}.{prop.Name}";

                _sb.AppendLine($"{indent}/// <summary>Forwards {_aliasedTypeName}.{prop.Name}.</summary>");
                _sb.AppendLine($"{indent}public static {returnTypeStr} {prop.Name}");
                _sb.AppendLine($"{indent}{{");
                _sb.AppendLine($"{indent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}    get => {valueExpr};");
                _sb.AppendLine($"{indent}}}");
                _sb.AppendLine();
            }
            else if (member is IFieldSymbol {IsReadOnly: true} field)
            {
                var returnTypeStr = SymbolEqualityComparer.Default.Equals(field.Type, _alias.AliasedType)
                    ? _structName
                    : field.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                
                var needsConversion = SymbolEqualityComparer.Default.Equals(field.Type, _alias.AliasedType);
                var valueExpr = needsConversion
                    ? $"new {_structName}({_aliasedTypeFullName}.{field.Name})"
                    : $"{_aliasedTypeFullName}.{field.Name}";

                _sb.AppendLine($"{indent}/// <summary>Forwards {_aliasedTypeName}.{field.Name}.</summary>");
                _sb.AppendLine($"{indent}public static {returnTypeStr} {field.Name} => {valueExpr};");
                _sb.AppendLine();
            }
        }

        _sb.AppendLine($"{indent}#endregion");
        _sb.AppendLine();
    }

    private void AppendInstanceMembers()
    {
        var indent = GetMemberIndent();
        var aliasedType = _alias.AliasedType;

        // Get instance fields (e.g. Vector3.X, Y, Z are fields, not properties)
        var instanceFields = aliasedType.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(f => !f.IsStatic && f is {IsImplicitlyDeclared: false, DeclaredAccessibility: Accessibility.Public})
            .ToList();

        // Get instance properties
        var instanceProps = aliasedType.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && p.DeclaredAccessibility == Accessibility.Public)
            .Where(p => !p.IsIndexer) // Skip indexers
            .ToList();

        // Get instance methods (excluding special ones)
        var instanceMethods = aliasedType.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => !m.IsStatic && m.DeclaredAccessibility == Accessibility.Public)
            .Where(m => m.MethodKind == MethodKind.Ordinary)
            .Where(m => !m.Name.StartsWith("get_") && !m.Name.StartsWith("set_"))
            .Where(m => m.Name != "GetHashCode" && m.Name != "Equals" && m.Name != "ToString" && m.Name != "CompareTo")
            .ToList();

        if (instanceFields.Count == 0 && instanceProps.Count == 0 && instanceMethods.Count == 0) return;

        _sb.AppendLine($"{indent}#region Instance Members");
        _sb.AppendLine();

        // Generate field forwarders (exposed as readonly properties)
        foreach (var field in instanceFields)
        {
            var returnTypeStr = SymbolEqualityComparer.Default.Equals(field.Type, _alias.AliasedType)
                ? _structName
                : field.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var needsConversion = SymbolEqualityComparer.Default.Equals(field.Type, _alias.AliasedType);
            var valueExpr = needsConversion ? $"new {_structName}(_value.{field.Name})" : $"_value.{field.Name}";

            _sb.AppendLine($"{indent}/// <summary>Forwards {_aliasedTypeName}.{field.Name}.</summary>");
            _sb.AppendLine($"{indent}public {returnTypeStr} {field.Name}");
            _sb.AppendLine($"{indent}{{");
            _sb.AppendLine($"{indent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            _sb.AppendLine($"{indent}    get => {valueExpr};");
            _sb.AppendLine($"{indent}}}");
            _sb.AppendLine();
        }

        // Generate property forwarders
        foreach (var prop in instanceProps)
        {
            var returnTypeStr = SymbolEqualityComparer.Default.Equals(prop.Type, _alias.AliasedType)
                ? _structName
                : prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            _sb.AppendLine($"{indent}/// <summary>Forwards {_aliasedTypeName}.{prop.Name}.</summary>");
            _sb.AppendLine($"{indent}public {returnTypeStr} {prop.Name}");
            _sb.AppendLine($"{indent}{{");
            
            if (prop.GetMethod != null)
            {
                var needsConversion = SymbolEqualityComparer.Default.Equals(prop.Type, _alias.AliasedType);
                var valueExpr = needsConversion ? $"new {_structName}(_value.{prop.Name})" : $"_value.{prop.Name}";
                _sb.AppendLine($"{indent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                _sb.AppendLine($"{indent}    get => {valueExpr};");
            }
            
            _sb.AppendLine($"{indent}}}");
            _sb.AppendLine();
        }

        // Generate method forwarders
        foreach (var method in instanceMethods)
        {
            var skipReturnWrapping = _alias.AliasedType.IsValueType &&
                _alias.AliasedType.SpecialType != SpecialType.None;
            var returnTypeStr = method.ReturnsVoid
                ? "void"
                : (SymbolEqualityComparer.Default.Equals(method.ReturnType, _alias.AliasedType) && !skipReturnWrapping)
                    ? _structName
                    : method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var parameters = string.Join(", ", method.Parameters.Select(p =>
            {
                var isAliasedType = SymbolEqualityComparer.Default.Equals(p.Type, _alias.AliasedType);
                // out parameters of the aliased type must keep the underlying type
                // to avoid CS0192 (cannot pass readonly field as ref/out)
                var paramType = (isAliasedType && p.RefKind != RefKind.Out)
                    ? _structName
                    : p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var refKind = p.RefKind switch
                {
                    RefKind.Ref => "ref ",
                    RefKind.Out => "out ",
                    RefKind.In => "in ",
                    _ => ""
                };
                return $"{refKind}{paramType} {p.Name}";
            }));

            var arguments = string.Join(", ", method.Parameters.Select(p =>
            {
                var refKind = p.RefKind switch
                {
                    RefKind.Ref => "ref ",
                    RefKind.Out => "out ",
                    RefKind.In => "in ",
                    _ => ""
                };
                var isAliasedType = SymbolEqualityComparer.Default.Equals(p.Type, _alias.AliasedType);
                // out parameters of the aliased type are passed directly (no ._value conversion)
                var arg = (isAliasedType && p.RefKind != RefKind.Out) ? $"{p.Name}._value" : p.Name;
                return $"{refKind}{arg}";
            }));

            var needsReturnConversion = !method.ReturnsVoid && !skipReturnWrapping &&
                SymbolEqualityComparer.Default.Equals(method.ReturnType, _alias.AliasedType);
            var returnExpr = method.ReturnsVoid
                ? $"_value.{method.Name}({arguments})"
                : needsReturnConversion
                    ? $"new {_structName}(_value.{method.Name}({arguments}))"
                    : $"_value.{method.Name}({arguments})";

            _sb.AppendLine($"{indent}/// <summary>Forwards {_aliasedTypeName}.{method.Name}.</summary>");
            _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");

            _sb.AppendLine(
                method.ReturnsVoid 
                    ? $"{indent}public void {method.Name}({parameters}) => {returnExpr};" 
                    : $"{indent}public {returnTypeStr} {method.Name}({parameters}) => {returnExpr};"
                );
            
            _sb.AppendLine();
        }

        _sb.AppendLine($"{indent}#endregion");
        _sb.AppendLine();
    }

    private void AppendToString()
    {
        var indent = GetMemberIndent();
        var isRefType = !_alias.AliasedType.IsValueType;

        var toStringExpr = isRefType ? "_value?.ToString() ?? \"\"" : "_value.ToString()";
        _sb.AppendLine($"{indent}/// <inheritdoc/>");
        _sb.AppendLine($"{indent}public override string ToString() => {toStringExpr};");
        _sb.AppendLine();

        // Add IFormattable.ToString if the aliased type implements it
        if (ImplementsInterface(_alias.AliasedType, "System.IFormattable"))
        {
            _sb.AppendLine($"{indent}/// <inheritdoc/>");
            _sb.AppendLine($"{indent}public string ToString(string? format, IFormatProvider? formatProvider) => _value.ToString(format, formatProvider);");
            _sb.AppendLine();
        }
    }

    private void AppendGetHashCode()
    {
        var indent = GetMemberIndent();
        var isRefType = !_alias.AliasedType.IsValueType;

        var hashExpr = isRefType ? "_value?.GetHashCode() ?? 0" : "_value.GetHashCode()";
        _sb.AppendLine($"{indent}/// <inheritdoc/>");
        _sb.AppendLine($"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"{indent}public override int GetHashCode() => {hashExpr};");
        _sb.AppendLine();
    }

    private string GetMemberIndent() => string.IsNullOrEmpty(_namespace) ? "    " : "        ";

    private IEnumerable<IMethodSymbol> GetBinaryOperators(ITypeSymbol type)
    {
        return type.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.MethodKind == MethodKind.UserDefinedOperator)
            .Where(m => m.Parameters.Length == 2);
    }

    private IEnumerable<IMethodSymbol> GetUnaryOperators(ITypeSymbol type)
    {
        return type.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.MethodKind == MethodKind.UserDefinedOperator)
            .Where(m => m.Parameters.Length == 1);
    }

    private static string? GetOperatorSymbol(string operatorName)
    {
        return operatorName switch
        {
            "op_Addition" => "+",
            "op_Subtraction" => "-",
            "op_Multiply" => "*",
            "op_Division" => "/",
            "op_Modulus" => "%",
            "op_BitwiseAnd" => "&",
            "op_BitwiseOr" => "|",
            "op_ExclusiveOr" => "^",
            "op_LeftShift" => "<<",
            "op_RightShift" => ">>",
            "op_UnaryNegation" => "-",
            "op_UnaryPlus" => "+",
            "op_LogicalNot" => "!",
            "op_OnesComplement" => "~",
            "op_Increment" => "++",
            "op_Decrement" => "--",
            "op_LessThan" => "<",
            "op_GreaterThan" => ">",
            "op_LessThanOrEqual" => "<=",
            "op_GreaterThanOrEqual" => ">=",
            "op_Equality" => "==",
            "op_Inequality" => "!=",
            _ => null
        };
    }

    /// <summary>
    /// Returns the built-in binary operator metadata names for a primitive SpecialType.
    /// Primitives use compiler-intrinsic operators not visible as UserDefinedOperator members.
    /// </summary>
    private static IReadOnlyList<string> GetBuiltInBinaryOperatorNames(SpecialType specialType)
    {
        switch (specialType)
        {
            case SpecialType.System_Int32:
            case SpecialType.System_Int64:
            case SpecialType.System_Int16:
            case SpecialType.System_Byte:
            case SpecialType.System_SByte:
            case SpecialType.System_UInt16:
            case SpecialType.System_UInt32:
            case SpecialType.System_UInt64:
                return
                [
                    "op_Addition", "op_Subtraction", "op_Multiply", "op_Division", "op_Modulus",
                    "op_BitwiseAnd", "op_BitwiseOr", "op_ExclusiveOr", "op_LeftShift", "op_RightShift",
                ];
            case SpecialType.System_Single:
            case SpecialType.System_Double:
            case SpecialType.System_Decimal:
                return ["op_Addition", "op_Subtraction", "op_Multiply", "op_Division", "op_Modulus"];
            case SpecialType.System_Boolean:
                return ["op_BitwiseAnd", "op_BitwiseOr", "op_ExclusiveOr"];
            case SpecialType.System_String:
                return ["op_Addition"];
            default:
                return [];
        }
    }

    /// <summary>
    /// Returns the built-in unary operator metadata names for a primitive SpecialType.
    /// </summary>
    private static IReadOnlyList<string> GetBuiltInUnaryOperatorNames(SpecialType specialType)
    {
        switch (specialType)
        {
            case SpecialType.System_Int32:
            case SpecialType.System_Int64:
            case SpecialType.System_Int16:
            case SpecialType.System_SByte:
                return ["op_UnaryNegation", "op_UnaryPlus", "op_OnesComplement"];
            case SpecialType.System_Byte:
            case SpecialType.System_UInt16:
            case SpecialType.System_UInt32:
            case SpecialType.System_UInt64:
                return ["op_UnaryPlus", "op_OnesComplement"];
            case SpecialType.System_Single:
            case SpecialType.System_Double:
            case SpecialType.System_Decimal:
                return ["op_UnaryNegation", "op_UnaryPlus"];
            case SpecialType.System_Boolean:
                return ["op_LogicalNot"];
            default:
                return [];
        }
    }

    /// <summary>
    /// Returns true if the given operator name is a shift operator (where the right operand is always int).
    /// </summary>
    private static bool IsShiftOperator(string opName)
    {
        return opName == "op_LeftShift" || opName == "op_RightShift";
    }

    private bool ImplementsInterface(ITypeSymbol type, string interfaceFullName)
    {
        // Handle generic interfaces like IComparable`1
        if (interfaceFullName.Contains("`"))
        {
            var baseName = interfaceFullName.Split('`')[0];
            return type.AllInterfaces.Any(i =>
                i.OriginalDefinition.ToDisplayString().StartsWith(baseName));
        }

        return type.AllInterfaces.Any(i => i.ToDisplayString() == interfaceFullName);
    }
}
