using Microsoft.CodeAnalysis;
using System.Text;

namespace newtype.generator;

/// <summary>
/// Generates the implementation code for a type alias.
/// </summary>
internal class AliasCodeGenerator
{
    // Mirror of System.Runtime.CompilerServices.MethodImplOptions values.
    private const int MethodImplNone = 0;
    private const int MethodImplAggressiveInlining = 256;
    private const int MethodImplNoInlining = 8;
    private const int MethodImplNoOptimization = 64;
    private const int MethodImplAggressiveOptimization = 512;

    private readonly AliasModel _model;
    private readonly StringBuilder _sb = new();

    public AliasCodeGenerator(AliasModel model)
    {
        _model = model;
    }

    public string Generate()
    {
        _sb.Clear();

        AppendHeader();
        AppendNamespaceOpen();
        AppendTypeOpen();

        AppendField();
        AppendConstructors();
        AppendValueProperty();
        AppendImplicitOperators();
        AppendBinaryOperators();
        AppendUnaryOperators();
        AppendComparisonOperators();
        AppendEqualityMembers();
        AppendStaticMembers();
        AppendInstanceMembers();
        AppendToString();
        if (!_model.IsRecord)
            AppendGetHashCode();

        AppendTypeClose();
        AppendNamespaceClose();

        return _sb.ToString();
    }

    private void AppendHeader()
    {
        _sb.AppendLine("// <auto-generated/>");
        _sb.AppendLine("#nullable enable");
        _sb.AppendLine();
        _sb.AppendLine("using System;");
        _sb.AppendLine("using System.Runtime.CompilerServices;");
        _sb.AppendLine();
    }

    private void AppendNamespaceOpen()
    {
        if (!string.IsNullOrEmpty(_model.Namespace))
        {
            _sb.AppendLine($"namespace {_model.Namespace}");
            _sb.AppendLine("{");
        }
    }

    private void AppendNamespaceClose()
    {
        if (!string.IsNullOrEmpty(_model.Namespace))
        {
            _sb.AppendLine("}");
        }
    }

    private void AppendTypeOpen()
    {
        var indent = string.IsNullOrEmpty(_model.Namespace) ? "" : "    ";
        var readonlyMod = (_model.IsReadonly && !_model.IsClass) ? "readonly " : "";
        var accessMod = _model.DeclaredAccessibility switch
        {
            Accessibility.Public => "public ",
            Accessibility.Internal => "internal ",
            Accessibility.Protected => "protected ",
            Accessibility.ProtectedOrInternal => "protected internal ",
            Accessibility.ProtectedAndInternal => "private protected ",
            Accessibility.Private => "private ",
            _ => ""
        };

        // Build interface list
        var interfaces = new List<string>
        {
            $"global::System.IEquatable<{_model.TypeName}>"
        };

        if (_model.ImplementsIComparable)
        {
            interfaces.Add($"global::System.IComparable<{_model.TypeName}>");
        }

        if (_model.ImplementsIFormattable)
        {
            interfaces.Add("global::System.IFormattable");
        }

        var interfaceList = string.Join(", ", interfaces);

        var typeKeyword = (_model.IsClass, _model.IsRecord) switch
        {
            (false, false) => "struct",
            (false, true) => "record struct",
            (true, false) => "class",
            (true, true) => "record class",
        };
        _sb.AppendLine($"{indent}{accessMod}{readonlyMod}partial {typeKeyword} {_model.TypeName} : {interfaceList}");
        _sb.AppendLine($"{indent}{{");
    }

    private void AppendTypeClose()
    {
        var indent = string.IsNullOrEmpty(_model.Namespace) ? "" : "    ";
        _sb.AppendLine($"{indent}}}");
    }

    private void AppendField()
    {
        var indent = GetMemberIndent();
        _sb.AppendLine($"{indent}private readonly {_model.AliasedTypeFullName} _value;");
        _sb.AppendLine();
    }

    private void AppendConstructors()
    {
        var indent = GetMemberIndent();

        // Constructor from aliased type (always emitted)
        _sb.AppendLine($"{indent}/// <summary>Creates a new {_model.TypeName} from a {_model.AliasedTypeMinimalName}.</summary>");
        AppendMethodImplAttribute(indent);
        _sb.AppendLine($"{indent}public {_model.TypeName}({_model.AliasedTypeFullName} value) => _value = value;");
        _sb.AppendLine();

        // Forward constructors from the aliased type (conditionally)
        if (!_model.SuppressConstructorForwarding)
        {
            foreach (var ctor in _model.ForwardedConstructors)
            {
                AppendForwardedConstructor(indent, ctor);
            }
        }
    }

    private void AppendValueProperty()
    {
        var indent = GetMemberIndent();
        _sb.AppendLine($"{indent}/// <summary>Gets the underlying value.</summary>");
        _sb.AppendLine($"{indent}public {_model.AliasedTypeFullName} Value");
        _sb.AppendLine($"{indent}{{");
        AppendMethodImplAttribute($"{indent}    ");
        _sb.AppendLine($"{indent}    get => _value;");
        _sb.AppendLine($"{indent}}}");
        _sb.AppendLine();
    }

    private void AppendImplicitOperators()
    {
        var indent = GetMemberIndent();

        // Implicit from aliased type to alias (T → Alias)
        if (!_model.SuppressImplicitWrap)
        {
            _sb.AppendLine($"{indent}/// <summary>Implicitly converts from {_model.AliasedTypeMinimalName} to {_model.TypeName}.</summary>");
            AppendMethodImplAttribute(indent);
            _sb.AppendLine($"{indent}public static implicit operator {_model.TypeName}({_model.AliasedTypeFullName} value) => new {_model.TypeName}(value);");
            _sb.AppendLine();
        }

        // Implicit from alias to aliased type (Alias → T)
        if (!_model.SuppressImplicitUnwrap)
        {
            _sb.AppendLine($"{indent}/// <summary>Implicitly converts from {_model.TypeName} to {_model.AliasedTypeMinimalName}.</summary>");
            AppendMethodImplAttribute(indent);
            _sb.AppendLine($"{indent}public static implicit operator {_model.AliasedTypeFullName}({_model.TypeName} value) => value._value;");
            _sb.AppendLine();
        }
    }

    private void AppendBinaryOperators()
    {
        var indent = GetMemberIndent();
        var emittedOps = new HashSet<string>();

        foreach (var op in _model.BinaryOperators)
        {
            var opSymbol = GetOperatorSymbol(op.Name);
            if (opSymbol == null) continue;

            // Skip equality/inequality - handled by AppendEqualityMembers
            if (op.Name == "op_Equality" || op.Name == "op_Inequality") continue;

            emittedOps.Add(op.Name);

            // Generate operator with both sides as our type (if both params are the aliased type)
            if (op.LeftIsAliasedType && op.RightIsAliasedType)
            {
                var returnTypeStr = op.ReturnIsAliasedType
                    ? _model.TypeName
                    : op.ReturnTypeFullName;

                var expr1 = WrapIfAlias(op.ReturnIsAliasedType, $"left._value {opSymbol} right._value");
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({_model.TypeName} left, {_model.TypeName} right) => {expr1};");
                _sb.AppendLine();

                // Also generate alias op T for cross-type interop
                // Note: T op alias is intentionally omitted here — when multiple aliases share
                // the same underlying type T, emitting both directions creates ambiguous overloads
                // (e.g. Position + Velocity would match both Vector3+Position and Velocity+Vector3).
                // The implicit conversion to T already covers the T op alias case.
                var expr2 = WrapIfAlias(op.ReturnIsAliasedType, $"left._value {opSymbol} right");
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({_model.TypeName} left, {_model.AliasedTypeFullName} right) => {expr2};");
                _sb.AppendLine();
            }
            // Operator with aliased type on left only — also emit T op Alias
            else if (op.LeftIsAliasedType && !op.RightIsAliasedType)
            {
                var returnTypeStr = op.ReturnIsAliasedType
                    ? _model.TypeName
                    : op.ReturnTypeFullName;

                var expr = WrapIfAlias(op.ReturnIsAliasedType, $"left._value {opSymbol} right");
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({_model.TypeName} left, {op.RightTypeFullName} right) => {expr};");
                _sb.AppendLine();
            }
            // Operator with aliased type on right only — also emit Alias op T
            else if (!op.LeftIsAliasedType && op.RightIsAliasedType)
            {
                var returnTypeStr = op.ReturnIsAliasedType
                    ? _model.TypeName
                    : op.ReturnTypeFullName;

                var expr = WrapIfAlias(op.ReturnIsAliasedType, $"left {opSymbol} right._value");
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({op.LeftTypeFullName} left, {_model.TypeName} right) => {expr};");
                _sb.AppendLine();
            }
        }

        // Emit built-in operators for primitive types not discovered via UserDefinedOperator
        var builtInOps = GetBuiltInBinaryOperatorNames(_model.AliasedTypeSpecialType);
        foreach (var opName in builtInOps)
        {
            if (emittedOps.Contains(opName)) continue;
            if (opName == "op_Equality" || opName == "op_Inequality") continue;

            var opSymbol = GetOperatorSymbol(opName);
            if (opSymbol == null) continue;

            if (IsShiftOperator(opName))
            {
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static {_model.TypeName} operator {opSymbol}({_model.TypeName} left, int right) => new {_model.TypeName}(left._value {opSymbol} right);");
                _sb.AppendLine();
            }
            else
            {
                // Alias op Alias
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static {_model.TypeName} operator {opSymbol}({_model.TypeName} left, {_model.TypeName} right) => new {_model.TypeName}(left._value {opSymbol} right._value);");
                _sb.AppendLine();

                // Alias op T
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static {_model.TypeName} operator {opSymbol}({_model.TypeName} left, {_model.AliasedTypeFullName} right) => new {_model.TypeName}(left._value {opSymbol} right);");
                _sb.AppendLine();

                // T op Alias
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static {_model.TypeName} operator {opSymbol}({_model.AliasedTypeFullName} left, {_model.TypeName} right) => new {_model.TypeName}(left {opSymbol} right._value);");
                _sb.AppendLine();
            }
        }
    }

    private void AppendUnaryOperators()
    {
        var indent = GetMemberIndent();
        var emittedOps = new HashSet<string>();

        foreach (var op in _model.UnaryOperators)
        {
            var opSymbol = GetOperatorSymbol(op.Name);
            if (opSymbol == null) continue;

            emittedOps.Add(op.Name);

            var returnTypeStr = op.ReturnIsAliasedType
                ? _model.TypeName
                : op.ReturnTypeFullName;

            var expr = WrapIfAlias(op.ReturnIsAliasedType, $"{opSymbol}value._value");
            AppendMethodImplAttribute(indent);
            _sb.AppendLine($"{indent}public static {returnTypeStr} operator {opSymbol}({_model.TypeName} value) => {expr};");
            _sb.AppendLine();
        }

        // Emit built-in unary operators for primitive types
        var builtInOps = GetBuiltInUnaryOperatorNames(_model.AliasedTypeSpecialType);
        foreach (var opName in builtInOps)
        {
            if (emittedOps.Contains(opName)) continue;

            var opSymbol = GetOperatorSymbol(opName);
            if (opSymbol == null) continue;

            AppendMethodImplAttribute(indent);
            _sb.AppendLine($"{indent}public static {_model.TypeName} operator {opSymbol}({_model.TypeName} value) => new {_model.TypeName}({opSymbol}value._value);");
            _sb.AppendLine();
        }
    }

    /// <summary>
    /// Wraps an expression in <c>new TypeName(...)</c> when the return type is the alias type,
    /// so generated operators don't depend on the implicit wrap conversion being present.
    /// </summary>
    private string WrapIfAlias(bool returnIsAliasedType, string expr)
    {
        return returnIsAliasedType
            ? $"new {_model.TypeName}({expr})"
            : expr;
    }

    private void AppendComparisonOperators()
    {
        var indent = GetMemberIndent();

        // Check if the type already has comparison operators (user-defined)
        var hasLessThan = false;
        foreach (var op in _model.BinaryOperators)
        {
            if (op.Name == "op_LessThan")
            {
                hasLessThan = true;
                break;
            }
        }

        if (hasLessThan)
        {
            // Type has user-defined comparison operators — already forwarded by AppendBinaryOperators
            return;
        }

        // For primitives with built-in comparison, use direct operators
        if (HasBuiltInComparisonOperators(_model.AliasedTypeSpecialType))
        {
            string[] ops = ["<", ">", "<=", ">="];
            foreach (var op in ops)
            {
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static bool operator {op}({_model.TypeName} left, {_model.TypeName} right) => left._value {op} right._value;");
                _sb.AppendLine();
            }

            return;
        }

        // Fallback: use IComparable<T>.CompareTo
        if (_model.ImplementsIComparable)
        {
            var isRefType = !_model.AliasedTypeIsValueType;

            string CompareExpr(string op) => isRefType
                ? $"(left._value is null ? (right._value is null ? 0 : -1) : left._value.CompareTo(right._value)) {op} 0"
                : $"left._value.CompareTo(right._value) {op} 0";

            string[] ops = ["<", ">", "<=", ">="];
            foreach (var op in ops)
            {
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static bool operator {op}({_model.TypeName} left, {_model.TypeName} right) => {CompareExpr(op)};");
                _sb.AppendLine();
            }
        }
    }

    private void AppendEqualityMembers()
    {
        var indent = GetMemberIndent();
        var isRefType = !_model.AliasedTypeIsValueType;
        var nullableParam = _model.IsClass ? "?" : "";

        // records synthesize Equals, ==, != — skip to avoid CS0111
        if (!_model.IsRecord)
        {
            // IEquatable<T>.Equals
            string equalsExpr;
            if (_model.IsClass)
                equalsExpr = isRefType
                    ? "other is not null && object.Equals(_value, other._value)"
                    : "other is not null && _value.Equals(other._value)";
            else
                equalsExpr = isRefType
                    ? "object.Equals(_value, other._value)"
                    : "_value.Equals(other._value)";
            _sb.AppendLine($"{indent}/// <inheritdoc/>");
            AppendMethodImplAttribute(indent);
            _sb.AppendLine($"{indent}public bool Equals({_model.TypeName}{nullableParam} other) => {equalsExpr};");
            _sb.AppendLine();

            // Object.Equals override
            _sb.AppendLine($"{indent}/// <inheritdoc/>");
            _sb.AppendLine($"{indent}public override bool Equals(object? obj) => obj is {_model.TypeName} other && Equals(other);");
            _sb.AppendLine();

            if (_model.IsClass)
            {
                // Class types need null-safe equality operators
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static bool operator ==({_model.TypeName}? left, {_model.TypeName}? right) => ReferenceEquals(left, right) || (left is not null && left.Equals(right));");
                _sb.AppendLine();

                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static bool operator !=({_model.TypeName}? left, {_model.TypeName}? right) => !(left == right);");
                _sb.AppendLine();
            }
            else if (_model.HasNativeEqualityOperator)
            {
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static bool operator ==({_model.TypeName} left, {_model.TypeName} right) => left._value == right._value;");
                _sb.AppendLine();

                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static bool operator !=({_model.TypeName} left, {_model.TypeName} right) => left._value != right._value;");
                _sb.AppendLine();
            }
            else
            {
                // Fallback: route through Equals
                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static bool operator ==({_model.TypeName} left, {_model.TypeName} right) => left.Equals(right);");
                _sb.AppendLine();

                AppendMethodImplAttribute(indent);
                _sb.AppendLine($"{indent}public static bool operator !=({_model.TypeName} left, {_model.TypeName} right) => !left.Equals(right);");
                _sb.AppendLine();
            }
        }

        // IComparable<T>.CompareTo if applicable
        if (_model.ImplementsIComparable)
        {
            string compareExpr;
            if (_model.IsClass)
                compareExpr = isRefType
                    ? "other is null ? 1 : (_value is null ? (other._value is null ? 0 : -1) : _value.CompareTo(other._value))"
                    : "other is null ? 1 : _value.CompareTo(other._value)";
            else
                compareExpr = isRefType
                    ? "_value is null ? (other._value is null ? 0 : -1) : _value.CompareTo(other._value)"
                    : "_value.CompareTo(other._value)";
            _sb.AppendLine($"{indent}/// <inheritdoc/>");
            AppendMethodImplAttribute(indent);
            _sb.AppendLine($"{indent}public int CompareTo({_model.TypeName}{nullableParam} other) => {compareExpr};");
            _sb.AppendLine();
        }
    }

    private void AppendStaticMembers()
    {
        var indent = GetMemberIndent();

        if (!_model.HasStaticMemberCandidates) return;

        _sb.AppendLine($"{indent}#region Static Members");
        _sb.AppendLine();

        foreach (var member in _model.StaticMembers)
        {
            var returnTypeStr = member.TypeIsAliasedType
                ? _model.TypeName
                : member.TypeFullName;

            var valueExpr = member.TypeIsAliasedType
                ? $"new {_model.TypeName}({_model.AliasedTypeFullName}.{member.Name})"
                : $"{_model.AliasedTypeFullName}.{member.Name}";

            if (member.IsProperty)
            {
                _sb.AppendLine($"{indent}/// <summary>Forwards {_model.AliasedTypeMinimalName}.{member.Name}.</summary>");
                _sb.AppendLine($"{indent}public static {returnTypeStr} {member.Name}");
                _sb.AppendLine($"{indent}{{");
                AppendMethodImplAttribute($"{indent}    ");
                _sb.AppendLine($"{indent}    get => {valueExpr};");
                _sb.AppendLine($"{indent}}}");
                _sb.AppendLine();
            }
            else if (member.IsReadonlyField)
            {
                _sb.AppendLine($"{indent}/// <summary>Forwards {_model.AliasedTypeMinimalName}.{member.Name}.</summary>");
                _sb.AppendLine($"{indent}public static {returnTypeStr} {member.Name} => {valueExpr};");
                _sb.AppendLine();
            }
        }

        _sb.AppendLine($"{indent}#endregion");
        _sb.AppendLine();
    }

    private void AppendInstanceMembers()
    {
        var indent = GetMemberIndent();

        if (_model.InstanceFields.Length == 0 && _model.InstanceProperties.Length == 0 && _model.InstanceMethods.Length == 0)
            return;

        _sb.AppendLine($"{indent}#region Instance Members");
        _sb.AppendLine();

        // Generate field forwarders (exposed as readonly properties)
        foreach (var field in _model.InstanceFields)
        {
            var returnTypeStr = field.TypeIsAliasedType
                ? _model.TypeName
                : field.TypeFullName;

            var valueExpr = field.TypeIsAliasedType
                ? $"new {_model.TypeName}(_value.{field.Name})"
                : $"_value.{field.Name}";

            _sb.AppendLine($"{indent}/// <summary>Forwards {_model.AliasedTypeMinimalName}.{field.Name}.</summary>");
            _sb.AppendLine($"{indent}public {returnTypeStr} {field.Name}");
            _sb.AppendLine($"{indent}{{");
            AppendMethodImplAttribute($"{indent}    ");
            _sb.AppendLine($"{indent}    get => {valueExpr};");
            _sb.AppendLine($"{indent}}}");
            _sb.AppendLine();
        }

        // Generate property forwarders
        foreach (var prop in _model.InstanceProperties)
        {
            var returnTypeStr = prop.TypeIsAliasedType
                ? _model.TypeName
                : prop.TypeFullName;

            _sb.AppendLine($"{indent}/// <summary>Forwards {_model.AliasedTypeMinimalName}.{prop.Name}.</summary>");
            _sb.AppendLine($"{indent}public {returnTypeStr} {prop.Name}");
            _sb.AppendLine($"{indent}{{");

            if (prop.HasGetter)
            {
                var valueExpr = prop.TypeIsAliasedType
                    ? $"new {_model.TypeName}(_value.{prop.Name})"
                    : $"_value.{prop.Name}";
                AppendMethodImplAttribute($"{indent}    ");
                _sb.AppendLine($"{indent}    get => {valueExpr};");
            }

            _sb.AppendLine($"{indent}}}");
            _sb.AppendLine();
        }

        // Generate method forwarders
        foreach (var method in _model.InstanceMethods)
        {
            var returnTypeStr = method.ReturnsVoid
                ? "void"
                : (method.ReturnIsAliasedType && !method.SkipReturnWrapping)
                    ? _model.TypeName
                    : method.ReturnTypeFullName;

            var parameters = string.Join(", ", method.Parameters.Array.Select(p =>
            {
                // out parameters of the aliased type must keep the underlying type
                var paramType = (p.IsAliasedType && p.RefKind != RefKind.Out)
                    ? _model.TypeName
                    : p.TypeFullName;
                var refKind = p.RefKind switch
                {
                    RefKind.Ref => "ref ",
                    RefKind.Out => "out ",
                    RefKind.In => "in ",
                    _ => ""
                };
                return $"{refKind}{paramType} {p.Name}";
            }));

            var arguments = string.Join(", ", method.Parameters.Array.Select(p =>
            {
                var refKind = p.RefKind switch
                {
                    RefKind.Ref => "ref ",
                    RefKind.Out => "out ",
                    RefKind.In => "in ",
                    _ => ""
                };
                // out parameters of the aliased type are passed directly (no ._value conversion)
                var arg = (p.IsAliasedType && p.RefKind != RefKind.Out) ? $"{p.Name}._value" : p.Name;
                return $"{refKind}{arg}";
            }));

            var needsReturnConversion = !method.ReturnsVoid && !method.SkipReturnWrapping &&
                                        method.ReturnIsAliasedType;
            var returnExpr = method.ReturnsVoid
                ? $"_value.{method.Name}({arguments})"
                : needsReturnConversion
                    ? $"new {_model.TypeName}(_value.{method.Name}({arguments}))"
                    : $"_value.{method.Name}({arguments})";

            _sb.AppendLine($"{indent}/// <summary>Forwards {_model.AliasedTypeMinimalName}.{method.Name}.</summary>");
            AppendMethodImplAttribute(indent);

            _sb.AppendLine(
                method.ReturnsVoid
                    ? $"{indent}public void {method.Name}({parameters}) => {returnExpr};"
                    : $"{indent}public {returnTypeStr} {method.Name}({parameters}) => {returnExpr};"
            );

            _sb.AppendLine();
        }

        _sb.AppendLine($"{indent}#endregion");
        _sb.AppendLine();
    }

    private void AppendToString()
    {
        var indent = GetMemberIndent();
        var isRefType = !_model.AliasedTypeIsValueType;

        var toStringExpr = isRefType ? "_value?.ToString() ?? \"\"" : "_value.ToString()";
        _sb.AppendLine($"{indent}/// <inheritdoc/>");
        _sb.AppendLine($"{indent}public override string ToString() => {toStringExpr};");
        _sb.AppendLine();

        if (_model.ImplementsIFormattable)
        {
            _sb.AppendLine($"{indent}/// <inheritdoc/>");
            _sb.AppendLine($"{indent}public string ToString(string? format, IFormatProvider? formatProvider) => _value.ToString(format, formatProvider);");
            _sb.AppendLine();
        }
    }

    private void AppendGetHashCode()
    {
        var indent = GetMemberIndent();
        var isRefType = !_model.AliasedTypeIsValueType;

        var hashExpr = isRefType ? "_value?.GetHashCode() ?? 0" : "_value.GetHashCode()";
        _sb.AppendLine($"{indent}/// <inheritdoc/>");
        AppendMethodImplAttribute(indent);
        _sb.AppendLine($"{indent}public override int GetHashCode() => {hashExpr};");
        _sb.AppendLine();
    }

    private void AppendForwardedConstructor(string indent, ConstructorInfo ctor)
    {
        var parameters = FormatConstructorParameters(ctor);
        var arguments = FormatConstructorArguments(ctor);

        _sb.AppendLine($"{indent}/// <summary>Forwards {_model.AliasedTypeMinimalName} constructor.</summary>");
        AppendMethodImplAttribute(indent);
        _sb.AppendLine($"{indent}public {_model.TypeName}({parameters}) => _value = new {_model.AliasedTypeFullName}({arguments});");
        _sb.AppendLine();
    }

    /// <summary>
    /// Emits a [MethodImpl(...)] attribute line, or nothing if the user set MethodImpl = default (0).
    /// </summary>
    private void AppendMethodImplAttribute(string indent)
    {
        var line = _model.MethodImplValue switch
        {
            MethodImplNone => null,
            MethodImplAggressiveInlining => $"{indent}[MethodImpl(MethodImplOptions.AggressiveInlining)]",
            MethodImplNoInlining => $"{indent}[MethodImpl(MethodImplOptions.NoInlining)]",
            MethodImplNoOptimization => $"{indent}[MethodImpl(MethodImplOptions.NoOptimization)]",
            MethodImplAggressiveOptimization => $"{indent}[MethodImpl(MethodImplOptions.AggressiveOptimization)]",
            _ => $"{indent}[MethodImpl((MethodImplOptions){_model.MethodImplValue})]",
        };

        if (line != null)
            _sb.AppendLine(line);
    }

    private static string FormatConstructorParameters(ConstructorInfo ctor)
    {
        return string.Join(", ", ctor.Parameters.Array.Select(p =>
        {
            var refKind = p.RefKind switch
            {
                RefKind.Ref => "ref ",
                RefKind.Out => "out ",
                RefKind.In => "in ",
                _ => ""
            };

            var paramsKeyword = p.IsParams ? "params " : "";

            var defaultValue = p.DefaultValueLiteral != null
                ? $" = {p.DefaultValueLiteral}"
                : "";

            return $"{paramsKeyword}{refKind}{p.TypeFullName} {p.Name}{defaultValue}";
        }));
    }

    private static string FormatConstructorArguments(ConstructorInfo ctor)
    {
        return string.Join(", ", ctor.Parameters.Array.Select(p =>
        {
            var refKind = p.RefKind switch
            {
                RefKind.Ref => "ref ",
                RefKind.Out => "out ",
                RefKind.In => "in ",
                _ => ""
            };
            return $"{refKind}{p.Name}";
        }));
    }

    private string GetMemberIndent() => string.IsNullOrEmpty(_model.Namespace) ? "    " : "        ";

    private static string? GetOperatorSymbol(string operatorName)
    {
        return operatorName switch
        {
            "op_Addition" => "+",
            "op_Subtraction" => "-",
            "op_Multiply" => "*",
            "op_Division" => "/",
            "op_Modulus" => "%",
            "op_BitwiseAnd" => "&",
            "op_BitwiseOr" => "|",
            "op_ExclusiveOr" => "^",
            "op_LeftShift" => "<<",
            "op_RightShift" => ">>",
            "op_UnaryNegation" => "-",
            "op_UnaryPlus" => "+",
            "op_LogicalNot" => "!",
            "op_OnesComplement" => "~",
            "op_Increment" => "++",
            "op_Decrement" => "--",
            "op_LessThan" => "<",
            "op_GreaterThan" => ">",
            "op_LessThanOrEqual" => "<=",
            "op_GreaterThanOrEqual" => ">=",
            "op_Equality" => "==",
            "op_Inequality" => "!=",
            _ => null
        };
    }

    /// <summary>
    /// Returns the built-in binary operator metadata names for a primitive SpecialType.
    /// </summary>
    private static IReadOnlyList<string> GetBuiltInBinaryOperatorNames(SpecialType specialType)
    {
        switch (specialType)
        {
            case SpecialType.System_Int32:
            case SpecialType.System_Int64:
            case SpecialType.System_Int16:
            case SpecialType.System_Byte:
            case SpecialType.System_SByte:
            case SpecialType.System_UInt16:
            case SpecialType.System_UInt32:
            case SpecialType.System_UInt64:
                return
                [
                    "op_Addition", "op_Subtraction", "op_Multiply", "op_Division", "op_Modulus",
                    "op_BitwiseAnd", "op_BitwiseOr", "op_ExclusiveOr", "op_LeftShift", "op_RightShift",
                ];
            case SpecialType.System_Single:
            case SpecialType.System_Double:
            case SpecialType.System_Decimal:
                return ["op_Addition", "op_Subtraction", "op_Multiply", "op_Division", "op_Modulus"];
            case SpecialType.System_Boolean:
                return ["op_BitwiseAnd", "op_BitwiseOr", "op_ExclusiveOr"];
            case SpecialType.System_String:
                return ["op_Addition"];
            default:
                return [];
        }
    }

    /// <summary>
    /// Returns the built-in unary operator metadata names for a primitive SpecialType.
    /// </summary>
    private static IReadOnlyList<string> GetBuiltInUnaryOperatorNames(SpecialType specialType)
    {
        switch (specialType)
        {
            case SpecialType.System_Int32:
            case SpecialType.System_Int64:
            case SpecialType.System_Int16:
            case SpecialType.System_SByte:
                return ["op_UnaryNegation", "op_UnaryPlus", "op_OnesComplement"];
            case SpecialType.System_Byte:
            case SpecialType.System_UInt16:
            case SpecialType.System_UInt32:
            case SpecialType.System_UInt64:
                return ["op_UnaryPlus", "op_OnesComplement"];
            case SpecialType.System_Single:
            case SpecialType.System_Double:
            case SpecialType.System_Decimal:
                return ["op_UnaryNegation", "op_UnaryPlus"];
            case SpecialType.System_Boolean:
                return ["op_LogicalNot"];
            default:
                return [];
        }
    }

    private static bool IsShiftOperator(string opName)
    {
        return opName == "op_LeftShift" || opName == "op_RightShift";
    }

    private static bool HasBuiltInComparisonOperators(SpecialType specialType)
    {
        return specialType is
            SpecialType.System_Byte or SpecialType.System_SByte or
            SpecialType.System_Int16 or SpecialType.System_UInt16 or
            SpecialType.System_Int32 or SpecialType.System_UInt32 or
            SpecialType.System_Int64 or SpecialType.System_UInt64 or
            SpecialType.System_Single or SpecialType.System_Double or
            SpecialType.System_Decimal or SpecialType.System_Char;
    }
}
